# 第一章 概论
1. 单CPU；多任务；CPU能和外设并行操作。
## 什么是操作系统
1. OS定义：是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充.OS是**直接控制和管理计算机硬件、软件资源，合理地对各类作业进行调度**，以方便用户使用的程序集合；完成硬件相关，应用无关的操作。
2. 引入OS的目标：
   1. 有效性：合理分配软硬件资源，组织工作流程
   2. 方便性：提供用户对硬件的接口
   3. 可扩充性：系统互操作，硬件拓展
## 操作系统历史
1. 无操作系统阶段：
   1. 串行，用户人工操作，用户独占全机
   2. 利用率 = 执行时间/(执行 + 读卡时间)
2. 单道批处理系统:
   1. 使用系统提供的作业处理语言JCL将所有作业输入，之后用户不在干预，*提高了利用率*
   2. 一个作业包括：用户程序、数据和作业说明书（作业控制语言）
   3. **批**：一个包含多个作业的，供一次加载的磁带或磁盘，使用一组相同的系统软件
   4. 自动性，顺序性，单道性
3. 多道批处理系统：
   1. 通过作业调度算法，将用户作业放入*后备队列中*，使得作业共享CPU资源（IO和CPU共同工作）。
   2. 宏观上并行，利用率高，但用户交互性差。微观上串行，各任务交替使用CPU。
## 操作系统基本类型
批处理操作系统、分时操作系统、实时操作系统。同时拥有两个以上的称为*通用操作系统*
1. 分时：一台计算机的一个周期分给多个用户使用。
   1.  时间片：将系统资源（尤其CPU时间）在时间上进行分割，每个时间段称为*时间片*，每个用户轮询使用时间片
   2.  分时技术：将处理机时间分成时间片，分配给各联机作业使用
   3.  分时操作系统：是一种联机的*多用户交互式的操作系统*。对每个用户能保证足够快的响应时间，并提供交互会话能力。
   4.  特征：交互性（用户和系统人机对话），多路性（多用户用一个机器），独立性（每个用户独立），及时性（用户能在短时间内获得响应）
2. 实时系统：
   1. *在规定的时间内*完成事件处理。
   2. 分类：
      > 实时控制系统:计算机控制系统，以计算机为核心控制生产过程
      > 实时信息处理系统:响应远程用户的提问，对信息进行检索等.
   3. 实时任务分类：周期性/非周期性
3. ![alt text](image.png)
4. 其他分类：
   1. 多处理机操作系统
      > 紧密耦合,松散耦合
      > 非对称式多重处理,对称式多重处理
   2. 网络操作系统：还能提供网络通信+网络服务。低耦合，以“协议”连接
   3. 分布式操作系统:分散处理和控制，以计算机网络为基础的；高耦合，统一的os
   4. 个人计算机操作系统：
      > 单用户单任务：只允许一个用户上机，且只允许用户程序作为一个任务运行
      > 单用户多任务:只允许一个用户上机，但允许将一个用户程序分为若干个任务并发执行
## 操作系统基本特征
最基本特征：并发、共享，两者相互存在关联。只有并发才能共享。
1. 并发：多个任务在同一*时间段*发生，操作系统要管理这些并发；并行：同一*时刻*发生。
2. 共享：多个进程**共享有限的计算机系统资源**。操作系统要对系统资源进行合理分配和使用。资源在一个时间段内交替被多个进程所用。
   1. 互斥共享：资源分配后不能被其他进程使用。如打印机
   2. 同时访问，如磁盘文件。
3. 虚拟：一个物理实体（CPU，磁盘）分成多个虚拟逻辑实体（分时，分空间）
4. 异步性：不确定性，进程执行顺序和时间不确定（由于分时等操作）
## 操作系统功能
操作系统组成：
1. 管理模块：针对不同管理对象的程序模块（核心kernel）
2. 用户接口：如外壳(shell)、窗口系统。在shell中，通过运行其他程序来完成各种功能
##### 处理机管理
进行*处理机资源调度*等问题。
1. *进程控制*：进程创建，撤销，挂起等。
2. *进程同步*：同步进程之间的*推进步骤*，分配处理机资源，确保*并发*的作业进程资源共享（互斥，同步方式）
3. *进程通信*：进程之间的数据交互。（读取进程，处理进程，打印进程）
4. *进程调度*：
   1. 作业调度：从作业的*后备队列*中选取若干个创建进程
   2. 进程调度：从进程的*就绪队列*中选取一个执行。
##### 存储管理
目标：提高利用率、方便用户使用、提供足够的存储空间、方便进程并发运行
1. *存储分配与回收*
2. *存储保护*：保证进程间互不干扰、相互保密；
3. *地址映射*：进程逻辑地址到内存物理地址的映射；
4. *内存扩充*：提高内存利用率、扩大进程的内存空间。
##### 设备管理
目标：方便设备使用、提高CPU与I/O设备利用率
1. *设备操作*：通过驱动程序完成对设备的操作。
2. *设备独立性*：提供统一的I/O设备接口，使应用程序独立于物理设备，在同样的接口和操作下完成不同的内容
3. *设备分配与回收*：在多用户间共享I/O设备资源。
##### 文件管理
解决软件资源的存储、共享、保密和保护
1. *文件存储空间管理*：为文件分配外存空间，提高外存效率
2. *目录管理*：解决文件检索问题
3. *文件的读写管理和存取控制*：根据用户需求从外存中存取数据。还要求文件保护，防止没有权限的用户读取。
4. 软件管理：版本管理，依赖管理等
##### 用户接口
*提供一个访问操作系统的友好接口*。一般有命令或系统调用。
1. *命令接口*：
   1. 联机用户接口.为联机用户提供,由键盘操作命令及命令解释程序所组成
   2. 脱机用户接口（批处理用户接口），为批处理作业的用户提供.由JCL组成
2. *程序接口*：用户程序获取系统资源服务的接口，由一组系统调用组成
3. *图形接口*：用户鼠标操作
## OS系统设计
1. 无结构操作系统：由众多过程构成
2. 模块化操作系统结构：模块化程序设计，将OS划分为多个小模块，小模块又分为更多模块。但划分根据功能，*没有区别对待共享资源和独占资源*。
3. 分层式操作系统结构：OS划分为多层，*每一层只能调用低层服务*。
4. 微内核的OS结构：OS内核只实现基本功能，*其他服务由用户态的进程实现*，C/S模式。用户程序（Client）通过OS内核向OS进程（Server）发送请求来获取系统服务。
## 双模式操作
1. 内核程序是操作系统最重要的程序。操作系统有内核Kernel就够了，但操作系统不只有内核（还有可视化界面等）。
2. 只有Kernel可以执行特权指令（内存清空等）。所以**CPU状态**分为：
   1. 内核态：管态，内核态，特权模式
   2. 用户态：目态，用户模式
3. 在PSW程序状态字寄存器中存在一位用于表示管态和目态。
4. 管态和目态切换方式：
   1. 管--目：一条特权指令，设置PSW对应位为用户态（目态），*表示操作系统主动让出控制权*
   2. 目--管：*由中断引发，只有当需要操作系统处理时，操作系统才强制夺回CPU控制权*；或当用户程序需要调用系统服务时切换。
5. 双模式操作目的：可以确保系统和用户程序不受错误的用户程序的影响.
6. 进行I/O保护：*所有I/O指令都是特权指令*
7. 存储保护：*防止进程访问其他进程内存，必须通过系统调用才能访问OS核心区*；增设**基地址寄存器，界限寄存器**，用以记录进程基地址和使用内存大小。
   1. 核心态（管态）可以访问任何内存（Kernel和用户进程空间）
   2. 设置基地址，界限寄存器的指令是特权指令。
8. CPU保护：存在硬件设置*时钟*，每个用户进程每N毫秒（时间片）中断一次，将CPU还给操作系统，*是实现分时系统的基础*；修改时钟指令是特权指令。
# 第二章 进程的描述与控制
进程：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。*是处理机，存储器和外设的最基本单位*
## 程序的执行特征
1. 顺序执行：单道批处理。有顺序性（顺序执行）、封闭性（独占全部资源）、可再现性（初始条件相同则结果相同）。
2. 并发执行：*如果不进行额外处理*，则有间断性（运行中可能中断）、非封闭（共享资源，可能被其他进程修改不变特征）、不可再现。所以必须要**额外操作来保证封闭性和可再现性**
## 进程的定义和特征
1. 进程中包含：
   1. 程序代码
   2. 程序数据、堆（程序员分配，malloc、new等，以链表形式存储）、栈（系统自动分配）
   3. PC等寄存器值
   4. 一组系统资源
2. 进程和程序：
   1. 程序是进程基础，进程是程序功能体现
   2. 程序是*静态*的，进程是*动态*的
   3. **通过多次执行，程序可以产生多个进程；通过调用关系，进程可以调用多个程序**
3. 进程特征：
   1. 动态性：创建产生，调度执行，撤销消亡。拥有*动态地址空间*。
   2. 并发性：内存中有多个进程，宏观上同时执行
   3. 独立性：除非相互通信，否则内存相互独立，*是资源调度的基础*
   4. 异步性：每个进程按照独立的速度进行
   5. 结构性：进程控制块(PCB，位于核心区) +  程序 +  数据 =  进程实体
## 进程控制块PCB
进程控制块（PCB，Process Control Block）是描述进程的数据结构，*记录用于描述进
程执行情况及控制进程运行的全部信息*。
1. 进程组成：
   1. PCB：操作系统为每个进程都维护一个PCB，保存进程的动态特征。
   2. 代码块：描述进程功能
   3. 数据块：描述操作对象和工作区
2. **PCB是进程存在的唯一标识**
3. PCB位于*核心区*，只能通过系统调用间接访问
4. PCB有什么：
   1. **进程描述信息**：进程标识符（内部标识符）；进程名（外部标识符）；父进程标识；用户标识符
   2. **处理机状态信息**：保存运行现场（PC，通用寄存器，PSW，栈指针）
   3. **进程调度信息**：用于操作系统调度；包括进程当前状态，优先级，运行统计信息等
   4. **进程控制信息**：程序段和数据段的地址；进程间同步和通信；资源占用信息（剩余资源）；链表存储的下一个进程指针。
## 进程基本状态
![alt text](image-1.png)
## 进程调度队列
操作系统维护很多队列，*用于表示进程状态*，如就绪队列，各种阻塞队列等；每当PCB记录的状态改变时，会脱离原先队列而加入正确队列。
1. PCB组织方式
   1. 链表
   2. 索引表：同一个状态的PCB装入同一个index表，一个index指向一个PCB。
2. PCB进程切换:![alt text](image-2.png)
## 进程控制
*进程管理中的最基本功能*
1. 进程生命周期：创建、运行、等待、唤醒、终止
2. 进程控制任务：进程的*创建、终止、进程状态的转变*等
3. 进程控制*由OS内核的原语*完成。
> 原语：由若干条指令构成的“原子操作(atomic operation)” 过程；
> 许多系统调用是原语，但原语不一定是系统调用。

4. 内核Kernel功能：*支撑功能；资源管理功能*
##### 进程创建
1. 父子进程：PCB中包含家族关系表项；子进程可以继承父进程资源，撤销子进程需要归还继承的资源；撤销父进程必须同时撤销子进程。
2. 进程创建定义：发生创建新进程事件后，*调用进程创建原语Creat()创建新进程*
3. 引起进程创建的事件：
   1. 系统初始化（系统内核创建）：分时系统的用户登录；批处理系统的作业调度。
   2. 提供服务（系统内核创建）：*用户请求创建进程*
   3. 应用请求（应用自己创建）：应用调用了原语Creat()
4. CREAT()原语：
   1. 申请空白PCB.
   2. 新进程分配空间.
   3. 初始化PCB：标识符；设置PC、SP；进程状态、优先级
   4. 插入就绪队列
##### 进程终止
1. 终止分类
   1. 正常结束：exit
   2. 异常结束：越界错误、超时错误等
   3. 外部干预：系统kill，（被）父进程终止
2. 终止过程
   1. *查询进程状态*：PCB表中检索出对应PCB，查询对应状态。
   2. *终止执行进程*：若处于执行状态则终止，设置调度标志为真并重新调度。
   3. *终止子进程*
   4. *释放资源*：将资源还给父进程，释放内存和lock
   5. *移除PCB*：将PCB从队列中移除
##### 进程的阻塞
1. 引起阻塞的条件
   1. 请求系统服务
   2. 启动操作
   3. 新数据尚未到
   4. 无新工作可做
2. 阻塞过程
   1. 若正在运行态，则调用阻塞原语BLOCK()，进入阻塞态。（是进程的主动操作）
   2. 引起处理机调度
3. Block()
   1. 保存当前CPU现场
   2. 置PCB阻塞态
   3. 进入等待队列
   4. 引起调度
##### 进程唤醒
1. 唤醒原因：等待的事件到达
2. 当其他进程发送信号到唤醒进程后，设置PCB状态为就绪。
3. WAKEUP()原语：
   1. 从等待队列中摘下被唤醒进程
   2. 置为就绪态
   3. 进入就绪队列
   4. 进程调度
4. Block()和WAKEUP()是功能相反的原语，*一个进程Block后一定要Wakeup*
5. ![SB](image-3.png)
##### 进程挂起
1. 挂起原因：
   1. *终端用户请求*：用户发现进程有问题，请求暂停
   2. *父进程请求*
   3. *负荷调节需要*：资源紧张时，将低优先级进程等暂时不执行的进程挂起，腾出空间
   4. *操作系统的需要*：检查资源或记账使用
2. 挂起作用：合理且充分地利用系统资源；进程挂起时，不在内存中，*仅在磁盘上存在镜像*
3. 挂起原语：SUSPEND():
   1. 将进程从内存调到外存，修改状态（PCB不修改）
   2. 若处于活动就绪/活动阻塞状态，则修改为静止就绪/静止阻塞
   3. 若运行，则重新调度
4. 激活原语：active():
   1. 原因：父进程或用户进程请求，或内存已有足够空间
   2. 从外存调入内存，改变进程的状态
5. ![alt text](image-4.png)
## 进程同步
进程具有**异步性**的特征。
*异步性*：各并发执行的进程以各自独立的、不可预知的速度向前推进。必须要通过某种机制同步起来
1. 进程之间的制约关系：
   1. 间接制约：两进程之间*资源共享*导致的制约
   2. 直接制约：进程间相互合作导致的制约
2. 临界资源：一个时间段内只允许一个进程使用的资源称为临界资源
##### 有限缓冲区的生产者与消费者问题
**生产者进程生产的信息由消费者进程消费**
假设生产者和消费者对于缓冲区有一个变量counter用于记录缓冲区数据数量。
1. 问题所在：
   1. 生产者生产数据后需要counter++;消费者消费数据后需要counter--
   2. 对应汇编代码：
   ```
   // 生产者
   LOAD Reg1 counter
   inc Reg1
   Store counter Reg1

   // 消费者
   LOAD Reg2 counter
   dec Reg2
   Store counter Reg2
   ```
   3. 当并发处理时，生产者和消费者汇编代码可能出现问题
   ![alt text](image-5.png)
2. *进程并发地共享数据导致不一致性*。需要保证counter++和counter--都是原子操作：**全过程无间断一次完成**
##### 互斥方式实现对临界资源的共享
1. 临界资源：硬件或软件（如外设、共享代码段），多个进程在对其进行访问时（关键是进行写入或修改），必须互斥地进行。
2. 临界区：
   1. 临界区是进程访问临界资源的一段代码，进入临界区后，*不允许其他进程进入各自的临界区*
   2. 进入区：进入临界区前检查是否可进入的代码。若可进入则设置”正在访问临界区“标志位。
   3. 退出区:清除“正在访问临界区”标志
   4. 剩余区：其他部分代码
3. 处于临界区时，说明这个进程正在使用处理机，*此时可以进行调度*。但存在一些不能调度的情况：
   1. 中断处理
   2. 处于系统内核的临界区时
   3. 处于必须不能中断的原子操作时
##### 同步机制需要满足的
1. 空闲则入：临界区能够进入则进入
2. 忙则等待：临界区满则进入等待
3. 有限等待：不能死等
4. 让权等待：不能进入临界区则让出控制器（转换到阻塞态）
##### 临界区同步算法
1. 2个进程同步：Peterson算法![alt text](image-7.png)
2. n个进程同步：面包店算法：![alt text](image-8.png)